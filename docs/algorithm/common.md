---
toc: content
group:
  title: 常用算法
  order: 1
title: 五大核心算法
order: 2
---

# 五大核心算法

## 递归算法

## 贪心算法

原理：一条路走到黑，选择当下局部最优的路线，没有后悔药。

经典问题：

- 背包问题

背包问题经典模板

```js
//01背包
for (var i = 0; i < n; i++) {
    for (var j = m; j >= V[i]; j--) {
        dp[j] = Math.max(dp[j], dp[j-V[i]] + W[i]);
    }
}

//完全背包
// 如果求组合数就是外层for循环遍历物品，内层for遍历背包。如果求排列数就是外层for遍历背包，内层for循环遍历物品。
// 求数量循环循序无所谓 w[i] 改成 1
for (var i = 0; i < n; i++) {
    for (int j = V[i]; j <= m; j++) {
        dp[j] = Math.max(dp[j], dp[j-V[i]] + W[i]);
    }
}
```

## 分治算法

原理：分而治之，先解决子问题，再将子问题的解合并求出原问题。

经典问题：

- 二分查找
- 归并排序
- 快速排序

## 动态规划

原理：上帝视角，手握无数平行宇宙的历史存档，同时发展出无数个未来。

经典问题：

- 爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
- 背包问题：给出一些资源（有总量及价值），给一个背包（有总容量），往背包里装资源，目标是在背包不超过总容量的情况下，装入更多的价值
- 硬币找零：给出面额不定的一定数量的零钱，以及需要找零的钱数，找出有多少种找零方案
- 图的全源最短路径：一个图中包含 u、v 顶点，找出从顶点 u 到顶点 v 的最短路径
- 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变剩下元素的顺序实现）

三要素

- 重叠子问题
- 最优子结构
- 状态转移方程

```javascript
例：假设你正在爬楼梯。需要 n 阶你才能到达楼顶，每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢
// 子问题：爬上倒数第二层的方法+倒数第一层的方法
// 最优子结构：推出原问题最优解
// 状态转移方程：dp[n] = dp[n-1] + dp[n-2]

let climbStairs = function(n) {
    let dp = [1, 1]
    for(let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    return dp[n]
}

// 优化空间复杂度
let climbStairsNew = function(n) {
    let dp1 = 1, dp2 = 1;
    for(let i = 2; i <= n; i++) {
        [dp1, dp2] = [dp2, dp1 + dp2]
    }
    return dp2
}

```

## 回溯算法

原理：一条路走到黑，手握后悔药，可以无数次重来。

经典问题：

- 深度优先搜索
- 0-1 背包问题
- 正则表达式匹配
- 八皇后
- 数独
- 全排列
